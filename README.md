# Домашнее задание к занятию «Жизненный цикл объекта. RAII»

Выполнив это задание, вы примените на практике идиому RAII и научитесь писать безопасные программы.

### Цель задания 

1. Научиться видеть потенциально опасные места в своих программах и исправлять это
2. Научиться использовать идиому RAII в своих программах

### Подготовка к выполнению домашнего задания

1. Для выполнения задания и прохождения курса нужен компьютер с операционной системой Windows или macOS и установленной на нём Microsoft Visual Studio 2022, готовой для разработки консольных программ на C++.
2. Аккаунт на [GitHub](https://github.com/). [Инструкция по регистрации на GitHub](https://github.com/netology-code/cppm-homeworks/tree/main/common/sign%20up).
3. Система контроля версий [Git](https://git-scm.com/), установленная локально. [Инструкция по установке Git](https://github.com/netology-code/cppm-homeworks/tree/main/common/download).

### Инструкция по выполнению домашнего задания

[Инструкция дана по ссылке](https://github.com/netology-code/cppm-homeworks/blob/main/common/readme.md).

------

### Задание 1

[Умный массив](01).

<details>
# Задача 1. Умный массив

### Описание
Вам нужно реализовать умный массив для данных типа int в духе идиомы RAII, который сам управляет своей памятью: самостоятельно выделяет её при создании и
очищает, когда объект данного класса не используется. 

Должны быть реализованы следующие функции:
* Конструктор, принмающий количество элементов, которое будет хранить массив.
* Функция добавления нового элемента в массив. Не забудьте обработать случай, когда количество элементов больше количества элементов, на которую выделена память.
* Функция получения элемента по индексу. Не забудьте проверку на корректность индекса.
* Деструктор.

### Пример правильной работы программы
Работа с вашим классом должна происходить так:

``` C++
try {
	smart_array arr(5);
	arr.add_element(1);
	arr.add_element(4);
	arr.add_element(155);
	arr.add_element(14);
	arr.add_element(15);
	std::cout << arr.get_element(1) << std::endl;
}
catch (const std::exception& ex) {
	std::cout << ex.what() << std::endl;
}
```
</details>


### Задание 2

[Копирование умных массивов](02).

<details>
# Задача 2. Копирование умных массивов

### Описание
В этом задании вам нужно поработать с классом умных массивов, который вы реализовали в предыдущем задании.
Сначала попробуйте создать два экземпляра вашего класса с различными элементами и присвоить один другому.

``` C++
smart_array arr(5);
arr.add_element(1);
arr.add_element(4);
arr.add_element(155);

smart_array new_array(2);
new_array.add_element(44); 
new_array.add_element(34);

arr = new_array
```
Попытайтесь самостоятельно разобраться, что произошло, и правильно реализовать копирование умных массивов.

#### Подсказки

> Не читайте этот раздел сразу. Попытайтесь сначала решить задачу самостоятельно :)

<details>

<summary>Что использовать для решения.</summary>

В программе возникает исключение, потому что компилятор самостоятельно сгенерировал оператор присваивания, который просто копирует все поля
одного объекта другому. В частности, проблема возникает из-за копирования указателя: оба объекта класса имеют одинаковый указатель на область
памяти и в своих деструкторах пытаются освободить его. Происходит двойное освобождение памяти.

</details>
</details>

------

### Правила приёма домашней работы

Чтобы сдать домашнее задание, прикрепите в личном кабинете ссылку на ваш репозиторий.

### Критерии оценки домашней работы

1. В личном кабинете прикреплена ссылка на репозиторий с кодом для заданий 1 и 2.
2. В ссылке содержится код, который при запуске выполняет описанный в задании алгоритм.
